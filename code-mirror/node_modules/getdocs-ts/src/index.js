"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gatherMany = exports.gather = void 0;
const typescript_1 = require("typescript");
const path_1 = require("path");
const ItemsWithParams = ["class", "enum", "interface", "typealias"];
// Used for recursion check in getObjectType
const gettingObjectTypes = [];
class Context {
    constructor(tc, exports, basedir, id, typeParams) {
        this.tc = tc;
        this.exports = exports;
        this.basedir = basedir;
        this.id = id;
        this.typeParams = typeParams;
    }
    extend(symbol, sep = "^") {
        let nm = typeof symbol == "string" ? symbol : symbol.name;
        return new Context(this.tc, this.exports, this.basedir, this.id ? this.id + sep + nm : nm, this.typeParams);
    }
    addParams(typeParams) {
        return new Context(this.tc, this.exports, this.basedir, this.id, typeParams.concat(this.typeParams));
    }
    gatherSymbols(symbols, target = {}, sep = ".", filter) {
        let gathered = 0;
        for (const symbol of symbols.filter(s => maybeDecl(s)).sort(compareSymbols)) {
            let name = this.symbolName(symbol);
            let item = this.extend(name, sep).itemForSymbol(symbol);
            if (item && (!filter || filter(name, item))) {
                target[name] = item;
                gathered++;
            }
        }
        return gathered ? target : null;
    }
    symbolName(symbol) {
        if (!/^__@/.test(symbol.name))
            return symbol.name;
        let name = symbol.name.slice(3).match(/^[^@]*/)[0];
        return name == "sym" ? "[unique symbol]" : `[symbol ${name}]`;
    }
    itemForSymbol(symbol, kind) {
        if (kind) {
            // Kind given
        }
        else if (symbol.flags & typescript_1.SymbolFlags.Alias) {
            let aliased = this.tc.getAliasedSymbol(symbol);
            if (this.isExternal(aliased))
                kind = "reexport";
            else
                return this.itemForSymbol(aliased);
        }
        else if (symbol.flags & typescript_1.SymbolFlags.PropertyOrAccessor)
            kind = "property";
        else if (symbol.flags & typescript_1.SymbolFlags.Method)
            kind = "method";
        else if (symbol.flags & typescript_1.SymbolFlags.Enum)
            kind = "enum";
        else if (symbol.flags & typescript_1.SymbolFlags.EnumMember)
            kind = "enummember";
        else if (symbol.flags & typescript_1.SymbolFlags.Class)
            kind = "class";
        else if (symbol.flags & typescript_1.SymbolFlags.Function)
            kind = "function";
        else if (symbol.flags & typescript_1.SymbolFlags.Interface)
            kind = "interface";
        else if (symbol.flags & typescript_1.SymbolFlags.TypeAlias)
            kind = "typealias";
        else if (symbol.flags & typescript_1.SymbolFlags.Variable)
            kind = "variable";
        else if (symbol.flags & typescript_1.SymbolFlags.TypeParameter)
            kind = "typeparam";
        else
            throw new Error(`Can not determine a kind for symbol ${symbol.escapedName} with flags ${symbol.flags}`);
        let binding = { kind, id: this.id }, type = this.symbolType(symbol);
        this.addSourceData(symbol.declarations || [], binding);
        let mods = symbol.valueDeclaration ? (0, typescript_1.getCombinedModifierFlags)(symbol.valueDeclaration) : 0;
        if (mods & typescript_1.ModifierFlags.Abstract)
            binding.abstract = true;
        if ((mods & typescript_1.ModifierFlags.Readonly) ||
            ((symbol.flags & (typescript_1.SymbolFlags.GetAccessor | typescript_1.SymbolFlags.SetAccessor)) == typescript_1.SymbolFlags.GetAccessor))
            binding.readonly = true;
        if ((mods & (typescript_1.ModifierFlags.Private | typescript_1.ModifierFlags.Protected)) || isHidden(binding.description))
            return null;
        if (symbol.flags & typescript_1.SymbolFlags.Optional) {
            binding.optional = true;
            type = this.tc.getNonNullableType(type);
        }
        let cx = this;
        let params = ItemsWithParams.includes(binding.kind) ? this.getTypeParams(decl(symbol)) : null;
        if (params)
            cx = cx.addParams(params);
        let typeDesc = kind == "enum" ? cx.getEnumType(symbol)
            : kind == "reexport" ? cx.getReferenceType(this.tc.getAliasedSymbol(symbol))
                : cx.getType(type, symbol);
        if (params)
            typeDesc.typeParams = params;
        if (binding.description && /@nonabstract\b/.test(binding.description)) {
            binding.description = binding.description.replace(/\s*@nonabstract\b/, "");
            if (typeDesc.type == "class") {
                delete binding.abstract;
                if (typeDesc.instanceProperties)
                    for (let name in typeDesc.instanceProperties)
                        delete typeDesc.instanceProperties[name].abstract;
            }
        }
        return Object.assign(Object.assign({}, binding), typeDesc);
    }
    getEnumType(symbol) {
        let properties = {};
        this.gatherSymbols(decl(symbol).members
            .map(member => this.tc.getSymbolAtLocation(member.name)), properties);
        for (let n in properties) {
            properties[n].type = symbol.name;
            properties[n].typeSource = this.nodePath(decl(symbol));
        }
        return { type: "enum", properties };
    }
    getType(type, forSymbol) {
        var _a, _b;
        if (type.aliasSymbol && !(forSymbol && (forSymbol.flags & typescript_1.SymbolFlags.TypeAlias)) && this.isAvailable(type.aliasSymbol))
            return this.getReferenceType(type.aliasSymbol, type.aliasTypeArguments);
        if (type.flags & typescript_1.TypeFlags.Any)
            return { type: "any" };
        if (type.flags & typescript_1.TypeFlags.String)
            return { type: "string" };
        if (type.flags & typescript_1.TypeFlags.Number)
            return { type: "number" };
        if (type.flags & typescript_1.TypeFlags.BigInt)
            return { type: "BigInt" };
        if (type.flags & typescript_1.TypeFlags.ESSymbol)
            return { type: "Symbol" };
        if (type.flags & typescript_1.TypeFlags.Boolean)
            return { type: "boolean" };
        if (type.flags & typescript_1.TypeFlags.Undefined)
            return { type: "undefined" };
        if (type.flags & typescript_1.TypeFlags.Null)
            return { type: "null" };
        if (type.flags & typescript_1.TypeFlags.Void)
            return { type: "void" };
        if (type.flags & typescript_1.TypeFlags.TemplateLiteral)
            return {
                type: "TemplateLiteral",
                typeArgs: type.types.map(t => this.getType(t))
            };
        // FIXME TypeScript doesn't export this. See https://github.com/microsoft/TypeScript/issues/26075, where they intend to fix that
        if (type.flags & typescript_1.TypeFlags.BooleanLiteral)
            return { type: type.intrinsicName };
        if (type.flags & typescript_1.TypeFlags.Literal)
            return { type: JSON.stringify(type.value) };
        if (type.flags & typescript_1.TypeFlags.Never)
            return { type: "never" };
        if (type.flags & typescript_1.TypeFlags.UnionOrIntersection) {
            let types = type.types, decl;
            // If we have a decl, use the order from that, since TypeScript 'normalizes' it in the type object
            if (forSymbol && (decl = maybeDecl(forSymbol))) {
                let typeNode = decl.type;
                if (typeNode && (typeNode.kind == typescript_1.SyntaxKind.UnionType || typeNode.kind == typescript_1.SyntaxKind.IntersectionType))
                    types = typeNode.types.map(node => this.tc.getTypeAtLocation(node));
            }
            let union = type.flags & typescript_1.TypeFlags.Union;
            let args = types.map(type => (type.flags & typescript_1.TypeFlags.Void) ? { type: "undefined" } : this.getType(type));
            // If both true and false occur in the union, combine them into boolean
            if (union && args.some(a => a.type == "true") && args.some(a => a.type == "false"))
                args = [{ type: "boolean" }].concat(args.filter(a => a.type != "true" && a.type != "false"));
            // Move null and undefined types to the end
            for (let tp of ["null", "undefined"]) {
                let index = args.findIndex(a => a.type == tp);
                if (index > -1 && index != args.length - 1)
                    args.push(args.splice(index, 1)[0]);
            }
            return {
                type: union ? "union" : "intersection",
                typeArgs: args
            };
        }
        if (type.flags & typescript_1.TypeFlags.TypeParameter) {
            let name = type.symbol.name, found = this.typeParams.find(p => p.name == name);
            if (!found && ((_b = (_a = maybeDecl(type.symbol)) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.kind) != typescript_1.SyntaxKind.InferType)
                throw new Error(`Unknown type parameter ${name}`);
            return { type: name, typeParamSource: found ? found.id : this.id };
        }
        if (type.flags & typescript_1.TypeFlags.Index) {
            return { type: "keyof", typeArgs: [this.getType(type.type)] };
        }
        if (type.flags & typescript_1.TypeFlags.IndexedAccess) {
            return { type: "indexed", typeArgs: [this.getType(type.objectType),
                    this.getType(type.indexType)] };
        }
        if (type.flags & typescript_1.TypeFlags.Conditional) {
            let { root } = type;
            return { type: "conditional",
                typeArgs: [this.getType(root.checkType), this.getType(root.extendsType),
                    this.getType(this.tc.getTypeFromTypeNode(root.node.trueType)),
                    this.getType(this.tc.getTypeFromTypeNode(root.node.falseType))] };
        }
        if (type.flags & typescript_1.TypeFlags.Object) {
            let objFlags = type.objectFlags;
            if (forSymbol && (forSymbol.flags & typescript_1.SymbolFlags.Class))
                return this.getClassType(type);
            if (forSymbol && (forSymbol.flags & typescript_1.SymbolFlags.Interface))
                return this.getObjectType(type, forSymbol);
            if ((objFlags & (typescript_1.ObjectFlags.Reference | typescript_1.ObjectFlags.Interface)) &&
                type.symbol && this.isAvailable(type.symbol))
                return this.getReferenceType(type.symbol, type.typeArguments, type);
            // Tuples have a weird structure where they point as references at a generic tuple type
            if (objFlags & typescript_1.ObjectFlags.Reference) {
                let target = type.target;
                if ((target.flags & typescript_1.TypeFlags.Object) && (target.objectFlags & typescript_1.ObjectFlags.Tuple))
                    return { type: "tuple", typeArgs: type.typeArguments.map(t => this.getType(t)) };
            }
            if (objFlags & typescript_1.ObjectFlags.Mapped) {
                // Instantiated types replace the type they are defined as with
                // some messy out-of context instantiation of the way that type
                // itself is defined. Here we try to fish the original
                // definition out of the syntax tree.
                if (objFlags & typescript_1.ObjectFlags.Instantiated) {
                    let decl = forSymbol && maybeDecl(forSymbol);
                    if ((decl === null || decl === void 0 ? void 0 : decl.kind) == typescript_1.SyntaxKind.TypeAliasDeclaration &&
                        decl.type.kind == typescript_1.SyntaxKind.TypeReference) {
                        let ref = decl.type;
                        let name = this.tc.getTypeAtLocation(ref.typeName);
                        let args = (ref.typeArguments || []).map(n => this.tc.getTypeAtLocation(n));
                        return this.getReferenceType(name.aliasSymbol || name.symbol, args);
                    }
                    return { type: "instantiated" };
                }
                let decl = maybeDecl(type.symbol), innerType = decl && decl.type;
                let typeParam = decl && decl.typeParameter ? this.getTypeParam(decl.typeParameter) : null;
                let cx = typeParam ? this.addParams([typeParam]) : this;
                let result = {
                    type: typeParam ? "mapped" : "Object",
                    typeArgs: [innerType ? cx.getType(this.tc.getTypeAtLocation(innerType)) : { type: "any" }]
                };
                if (typeParam)
                    result.key = typeParam;
                return result;
            }
            let call = type.getCallSignatures();
            if (call.length)
                return { type: "Function", signatures: call.map(c => this.getCallSignature(c, "function")) };
            // See `createAnonymousTypeNode` for more fine-grained `typeof` conditionals
            if ((type.symbol.flags & (typescript_1.SymbolFlags.Class | typescript_1.SymbolFlags.Enum | typescript_1.SymbolFlags.ValueModule)) &&
                this.isAvailable(type.symbol))
                return { type: "typeof", typeArgs: [this.getReferenceType(type.symbol)] };
            return this.getObjectType(type, objFlags & typescript_1.ObjectFlags.Interface ? type.symbol : undefined);
        }
        if (type.flags & typescript_1.TypeFlags.Unknown)
            return { type: "unknown" };
        if (type.flags & typescript_1.TypeFlags.NonPrimitive)
            return { type: "object" };
        let maybePath = "";
        let maybeD, maybeS = forSymbol || type.symbol;
        if (maybeD = maybeS && maybeDecl(maybeS)) {
            let pos = (0, typescript_1.getLineAndCharacterOfPosition)(maybeD.getSourceFile(), maybeD.pos);
            maybePath = ` at ${this.nodePath(maybeD)}:${pos.line - 1}:${pos.character - 1}`;
        }
        throw new Error(`Unsupported type ${this.tc.typeToString(type)} with flags ${type.flags}${maybePath}`);
    }
    getObjectType(type, interfaceSymbol) {
        if (gettingObjectTypes.includes(type))
            return { type: "Object" };
        gettingObjectTypes.push(type);
        try {
            let out = { type: interfaceSymbol ? "interface" : "Object" };
            let call = type.getCallSignatures(), ctor = type.getConstructSignatures();
            let props = type.getProperties();
            let strIndex = type.getStringIndexType(), numIndex = type.getNumberIndexType(), indexItem;
            let intDecl = interfaceSymbol && maybeDecl(interfaceSymbol);
            let members;
            if (intDecl && (0, typescript_1.isInterfaceDeclaration)(intDecl)) {
                let declared = intDecl.members.filter(member => member.name).map(member => this.tc.getSymbolAtLocation(member.name).name);
                props = props.filter(prop => declared.includes(prop.name));
                members = intDecl.members;
                if (intDecl.heritageClauses && intDecl.heritageClauses.length)
                    out.implements = intDecl.heritageClauses[0].types.map(node => this.getType(this.tc.getTypeAtLocation(node)));
            }
            if (strIndex || numIndex) {
                if (!members) {
                    let sym = type.getSymbol(), decl = sym && maybeDecl(sym);
                    if (decl && decl.kind == typescript_1.SyntaxKind.TypeLiteral)
                        members = decl.members;
                }
                let indexSym;
                if (members)
                    for (let m of members)
                        if (m.kind == typescript_1.SyntaxKind.IndexSignature)
                            indexSym = m.symbol;
                if (indexSym) {
                    indexItem = this.extend(strIndex ? "string" : "number").itemForSymbol(indexSym, "property");
                    if (indexItem && indexItem.type == "any")
                        Object.assign(indexItem, this.getType(strIndex || numIndex));
                }
                if (!props.length && !call.length && !ctor.length && !out.implements && !(indexItem === null || indexItem === void 0 ? void 0 : indexItem.description)) {
                    if (strIndex)
                        return { type: "Object", typeArgs: [this.getType(strIndex)] };
                    if (numIndex)
                        return { type: "Array", typeArgs: [this.getType(numIndex)] };
                }
            }
            if (call.length || ctor.length)
                out.signatures = call.map(s => this.getCallSignature(s, "function"))
                    .concat(ctor.map(s => this.getCallSignature(s, "constructor")));
            let propObj = this.gatherSymbols(props);
            if (indexItem)
                (propObj || (propObj = {}))[`[${strIndex ? "string" : "number"}]`] = indexItem;
            if (propObj)
                out.properties = propObj;
            return out;
        }
        finally {
            gettingObjectTypes.pop();
        }
    }
    getClassType(type) {
        let out = { type: "class" };
        let classDecl = type.symbol.valueDeclaration;
        if (!classDecl || !(0, typescript_1.isClassLike)(classDecl))
            throw new Error("Class decl isn't class-like");
        let parentProps = [];
        if (classDecl.heritageClauses) {
            for (let heritage of classDecl.heritageClauses) {
                let parents = heritage.types.map(node => {
                    let type = this.tc.getTypeAtLocation(node);
                    for (let sym of type.getProperties())
                        parentProps.push(sym.name);
                    return this.getType(type);
                });
                if (heritage.token == typescript_1.SyntaxKind.ExtendsKeyword)
                    out.extends = parents[0];
                else
                    out.implements = parents;
            }
        }
        let definedProps = [], definedStatic = [], ctors = [];
        for (let member of classDecl.members) {
            let symbol = this.tc.getSymbolAtLocation(member.name || member);
            if (member.kind == typescript_1.SyntaxKind.Constructor) {
                ctors.push(member);
                for (let param of member.parameters) {
                    if ((0, typescript_1.getCombinedModifierFlags)(param) & (typescript_1.ModifierFlags.Public | typescript_1.ModifierFlags.Readonly))
                        definedProps.push(this.tc.getSymbolAtLocation(param.name).name);
                }
            }
            else if ((0, typescript_1.getCombinedModifierFlags)(member) & typescript_1.ModifierFlags.Static) {
                definedStatic.push(symbol.name);
            }
            else {
                definedProps.push(symbol.name);
            }
        }
        let ctorItem, ctorSignatures = [];
        for (let ctor of ctors) {
            let signature = type.getConstructSignatures().find(sig => sig.getDeclaration() == ctor);
            if (!signature || ((0, typescript_1.getCombinedModifierFlags)(ctor) & (typescript_1.ModifierFlags.Private | typescript_1.ModifierFlags.Protected)))
                continue;
            let item = { kind: "constructor", id: this.id + ".constructor", type: "Function" };
            this.addSourceData([ctor], item);
            if (isHidden(item.description))
                continue;
            if (!ctorItem || item.description)
                ctorItem = item;
            ctorSignatures.push(this.extend("constructor", ".").getCallSignature(signature, "constructor", true));
            break;
        }
        if (ctorItem) {
            ctorItem.signatures = ctorSignatures;
            out.construct = ctorItem;
        }
        // FIXME I haven't found a less weird way to get the instance type
        let ctorType = type.getConstructSignatures()[0];
        if (ctorType) {
            let protoProps = ctorType.getReturnType().getProperties().filter(prop => definedProps.includes(prop.name));
            let instanceObj = this.gatherSymbols(protoProps, undefined, undefined, (name, value) => {
                return !!value.description || !parentProps.includes(name);
            });
            if (instanceObj)
                out.instanceProperties = instanceObj;
        }
        let props = type.getProperties().filter(prop => definedStatic.includes(prop.name));
        let propObj = this.gatherSymbols(props, undefined, "^");
        if (propObj)
            out.properties = propObj;
        return out;
    }
    getReferenceType(symbol, typeArgs, arityType) {
        let result = { type: symbol.name };
        let typeSource = this.nodePath(decl(symbol));
        if (!isBuiltin(typeSource))
            result.typeSource = typeSource;
        if (typeArgs) {
            let targetParams = arityType ? arityType.target.typeParameters : null;
            if (arityType)
                typeArgs = typeArgs.slice(0, targetParams ? targetParams.length : 0);
            if (typeArgs.length) {
                let args = typeArgs.map(arg => this.getType(arg));
                // If there are default types for the type parameters, drop
                // types that match the default from the list of arguments to
                // reduce noise.
                if (targetParams) {
                    let cx = null;
                    for (let i = targetParams.length - 1; i >= 0; i--) {
                        let deflt = targetParams[i].getDefault();
                        if (!deflt)
                            break;
                        if (!cx)
                            cx = this.addParams(args.map((a, i) => Object.assign({
                                name: targetParams[i].symbol.name,
                                id: String(i),
                                kind: "typeparam"
                            }, a)));
                        let compare = cx.getType(deflt);
                        if (compareTypes(args[i], compare, args))
                            args.pop();
                        else
                            break;
                    }
                }
                if (args.length)
                    result.typeArgs = args;
            }
        }
        return result;
    }
    getParams(signature) {
        return signature.getParameters().map(param => {
            let cx = this.extend(param), optional = false, type = cx.symbolType(param);
            let decl = param.valueDeclaration;
            if (decl && decl.questionToken) {
                optional = true;
                type = this.tc.getNonNullableType(type);
            }
            let result = Object.assign({ id: cx.id, kind: "parameter" }, cx.getType(type, param));
            if (decl)
                this.addSourceData([decl], result, !((0, typescript_1.getCombinedModifierFlags)(decl) & (typescript_1.ModifierFlags.Public | typescript_1.ModifierFlags.Readonly)));
            let deflt = decl && decl.initializer;
            if (deflt)
                result.default = deflt.getSourceFile().text.slice(deflt.pos, deflt.end).trim();
            if (deflt || optional)
                result.optional = true;
            if (decl && decl.dotDotDotToken)
                result.rest = true;
            if (param.valueDeclaration.name.kind == typescript_1.SyntaxKind.Identifier)
                result.name = param.name;
            return result;
        });
    }
    getTypeParams(decl) {
        let params = decl.typeParameters;
        return !params ? null : params.reduce(([res, cx], param) => {
            let p = cx.getTypeParam(param);
            return [res.concat(p), cx.addParams([p])];
        }, [[], this])[0];
    }
    getTypeParam(param) {
        let sym = this.tc.getSymbolAtLocation(param.name);
        let localCx = this.extend(sym);
        let result = { type: "typeparam", kind: "typeparam", name: sym.name, id: localCx.id };
        this.addSourceData([param], result);
        let constraint = (0, typescript_1.getEffectiveConstraintOfTypeParameter)(param), type;
        // Directly querying getTypeAtLocation for the constraint will
        // resolve keyof types for some reason, which can lead to very
        // ugly and verbose output. So this inspects the type node for
        // that case and manually handles it.
        if (constraint && constraint.kind == typescript_1.SyntaxKind.TypeOperator &&
            constraint.operator == typescript_1.SyntaxKind.KeyOfKeyword &&
            (type = this.tc.getTypeAtLocation(constraint.type)))
            result.implements = [{ type: "keyof", typeArgs: [this.getType(type)] }];
        else if (constraint && (type = this.tc.getTypeAtLocation(constraint)))
            result.implements = [localCx.addParams([result]).getType(type)];
        if (param.default)
            result.default = param.getSourceFile().text.slice(param.default.pos, param.default.end).trim();
        return result;
    }
    getCallSignature(signature, type, suppressReturn = false) {
        let cx = this;
        let typeParams = signature.typeParameters && this.getTypeParams(signature.getDeclaration());
        let out = { type };
        if (typeParams) {
            cx = cx.addParams(typeParams);
            out.typeParams = typeParams;
        }
        out.params = cx.getParams(signature);
        if (!suppressReturn) {
            let ret = signature.getReturnType();
            if (!(ret.flags & typescript_1.TypeFlags.Void))
                out.returns = cx.extend("returns").getType(ret);
        }
        return out;
    }
    symbolType(symbol) {
        let type = this.tc.getTypeOfSymbolAtLocation(symbol, decl(symbol));
        // FIXME this is weird and silly but for interface declarations TS gives a symbol type of any
        if (type.flags & typescript_1.TypeFlags.Any)
            type = this.tc.getDeclaredTypeOfSymbol(symbol);
        return type;
    }
    nodePath(node) {
        return (0, path_1.relative)(this.basedir, node.getSourceFile().fileName);
    }
    addSourceData(nodes, target, comments = true) {
        if (comments) {
            let comment = "";
            for (let node of nodes) {
                let c = getComments(node.kind == typescript_1.SyntaxKind.VariableDeclaration ? node.parent.parent : node);
                if (c)
                    comment += (comment ? "\n\n" : "") + c;
            }
            if (comment)
                target.description = comment;
        }
        const sourceFile = nodes[0].getSourceFile();
        if (!sourceFile)
            return; // Synthetic node
        let { pos } = nodes[0];
        while ((0, typescript_1.isWhiteSpaceLike)(sourceFile.text.charCodeAt(pos)))
            ++pos;
        const { line, character } = (0, typescript_1.getLineAndCharacterOfPosition)(sourceFile, pos);
        target.loc = { file: this.nodePath(nodes[0]), line: line + 1, column: character };
    }
    // Tells whether a symbol is either exported or external, and thus
    // can be used in the output
    isAvailable(symbol) {
        return this.exports.includes(symbol) || this.isExternal(symbol);
    }
    isExternal(symbol) {
        let decl = maybeDecl(symbol);
        if (!decl)
            return true;
        let path = (0, path_1.resolve)(decl.getSourceFile().fileName);
        return !path.startsWith(this.basedir + path_1.sep) || /\bnode_modules\b/.test(path.slice(this.basedir.length));
    }
}
function maybeDecl(symbol) {
    return symbol.valueDeclaration || (symbol.declarations && symbol.declarations[0]);
}
function decl(symbol) {
    let result = maybeDecl(symbol);
    if (!result)
        throw new Error(`No declaration available for symbol ${symbol.escapedName}`);
    return result;
}
function isBuiltin(path) {
    return /typescript\/lib\/.*\.es\d+.*\.d\.ts$/.test(path);
}
function compareSymbols(a, b) {
    let da = maybeDecl(a), db = maybeDecl(b);
    if (!da)
        return db ? -1 : 0;
    if (!db)
        return 1;
    let fa = da.getSourceFile().fileName, fb = db.getSourceFile().fileName;
    return fa == fb ? da.pos - db.pos : fa < fb ? -1 : 1;
}
function compareTypes(a, b, paramMap) {
    while (b.typeParamSource && paramMap[b.typeParamSource])
        b = paramMap[b.typeParamSource];
    if (a.type != b.type || a.typeSource != b.typeSource || a.typeParamSource != b.typeParamSource ||
        !a.properties != !b.properties || a.instanceProperties || b.instanceProperties ||
        !a.typeArgs != !b.typeArgs || !a.signatures != !b.signatures)
        return false;
    if (a.properties) {
        let aK = Object.keys(a.properties), bK = Object.keys(b.properties);
        if (aK.length != bK.length || !aK.every(k => b.properties[k] || compareTypes(a.properties[k], b.properties[k], paramMap)))
            return false;
    }
    if (a.typeArgs && (a.typeArgs.length != b.typeArgs.length ||
        !a.typeArgs.every((ta, i) => compareTypes(ta, b.typeArgs[i], paramMap))))
        return false;
    if (a.signatures && (a.signatures.length != b.signatures.length ||
        !a.signatures.every((s, i) => compareSignature(s, b.signatures[i], paramMap))))
        return false;
    return true;
}
function compareSignature(a, b, paramMap) {
    if (!a.returns != !b.returns || a.type != b.type || !a.typeParams != !b.typeParams)
        return false;
    if (a.params.length != b.params.length ||
        !a.params.every((p, i) => compareTypes(p, b.params[i], paramMap)))
        return false;
    if (a.returns && !compareTypes(a.returns, b.returns, paramMap))
        return false;
    return true;
}
function getComments(node) {
    let { pos } = node;
    const sourceFile = node.getSourceFile();
    if (!sourceFile)
        return ""; // Synthetic node
    const { text } = sourceFile;
    let lines = [], blankLine = false;
    function add(line) {
        if (blankLine) {
            blankLine = false;
            if (lines.length && /\S/.test(lines[lines.length - 1]))
                lines.push("");
        }
        lines.push(line);
    }
    while (pos < text.length) {
        const ch = text.charCodeAt(pos);
        if (ch === 47) { // slash
            const nextCh = text.charCodeAt(pos + 1);
            if (nextCh === 47) {
                let doc = text.charCodeAt(pos + 2) == 47;
                let start = pos += doc ? 3 : 2;
                while (pos < text.length && !(0, typescript_1.isLineBreak)(text.charCodeAt(pos)))
                    pos++;
                if (doc)
                    add(text.slice(start, pos));
            }
            else if (nextCh === 42) { // asterisk
                const doc = text.charCodeAt(pos + 2) == 42, start = pos + (doc ? 3 : 2);
                for (pos = start; pos < text.length; ++pos)
                    if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */)
                        break;
                if (doc)
                    add(text.slice(start, pos));
                pos += 2;
            }
        }
        else if ((0, typescript_1.isWhiteSpaceLike)(ch)) {
            pos++;
            if (ch == 10 && text.charCodeAt(pos) == 10)
                blankLine = true;
        }
        else {
            break;
        }
    }
    return stripComment(lines);
}
function stripComment(lines) {
    for (var head, i = 1; i < lines.length; i++) {
        var line = lines[i], lineHead = line.match(/^[\s\*]*/)[0];
        if (lineHead != line) {
            if (head == null) {
                head = lineHead;
            }
            else {
                var same = 0;
                while (same < head.length && head.charCodeAt(same) == lineHead.charCodeAt(same))
                    ++same;
                if (same < head.length)
                    head = head.slice(0, same);
            }
        }
    }
    if (head != null) {
        var startIndent = /^\s*/.exec(lines[0])[0];
        var trailing = /\s*$/.exec(head)[0];
        var extra = trailing.length - startIndent.length;
        if (extra > 0)
            head = head.slice(0, head.length - extra);
    }
    outer: for (var i = 0; i < lines.length; i++) {
        var line = lines[i].replace(/\s+$/, "");
        if (i == 0 && head != null) {
            for (var j = 0; j < head.length; j++) {
                var found = line.indexOf(head.slice(j));
                if (found == 0) {
                    lines[i] = line.slice(head.length - j);
                    continue outer;
                }
            }
        }
        if (head == null || i == 0)
            lines[i] = line.replace(/^[\s\*]*/, "");
        else if (line.length < head.length)
            lines[i] = "";
        else
            lines[i] = line.slice(head.length);
    }
    while (lines.length && !lines[lines.length - 1])
        lines.pop();
    while (lines.length && !lines[0])
        lines.shift();
    return lines.join("\n");
}
function isHidden(description) {
    return description && /@(internal|hide)\b/.test(description);
}
function gather(spec) {
    return gatherMany([spec])[0];
}
exports.gather = gather;
function gatherMany(specs) {
    let filenames = specs.map(s => s.filename);
    let configPath = (0, typescript_1.findConfigFile)(filenames[0], typescript_1.sys.fileExists);
    let host = (0, typescript_1.createCompilerHost)({});
    let options = configPath ? (0, typescript_1.getParsedCommandLineOfConfigFile)(configPath, {}, host).options : {};
    let program = (0, typescript_1.createProgram)({ rootNames: filenames, options, host });
    let tc = program.getTypeChecker();
    return specs.map(({ filename, basedir }) => {
        let items = Object.create(null);
        let sourceFile = program.getSourceFile(filename);
        if (!sourceFile)
            throw new Error(`Source file "${filename}" not found`);
        let fileSymbol = tc.getSymbolAtLocation(sourceFile);
        if (!fileSymbol)
            throw new Error(`No symbol for file "${filename}" (no exports?)`);
        let exports = tc.getExportsOfModule(fileSymbol);
        // Add all symbols aliased by exports to the set of things that
        // should be considered exported
        let closedExports = exports.slice();
        for (let i = 0; i < closedExports.length; i++) {
            let sym = closedExports[i], alias = (sym.flags & typescript_1.SymbolFlags.Alias) ? tc.getAliasedSymbol(sym) : null;
            if (alias && !closedExports.includes(alias))
                closedExports.push(alias);
        }
        new Context(tc, closedExports, (0, path_1.resolve)(basedir || (0, path_1.dirname)(configPath || filename)), "", []).gatherSymbols(exports, items, "");
        return items;
    });
}
exports.gatherMany = gatherMany;
//# sourceMappingURL=index.js.map